最后用了什么包
### 阅读每段代码时请打开对应的解释文档来阅读
按照代码顺序介绍
raw data 介绍
{"e": "aggTrade", "E": 1724457623290, "s": "BTCUSDT", "a": 3125698687, "p": "64078.61000000", "q": "0.10894000", "f": 3761589258, "l": 3761589259, "T": 1724457623289, "m": true, "M": true, "datetime": "1724457623.3997118"}
{"e": "aggTrade", "E": 1724457623292, "s": "BTCUSDT", "a": 3125698688, "p": "64076.44000000", "q": "0.00033000", "f": 3761589260, "l": 3761589260, "T": 1724457623291, "m": true, "M": true, "datetime": "1724457623.4028065"}
{"lastUpdateId": 50754183409, "bids": [["64076.44000000", "0.01987000"], ["64075.42000000", "0.00019000"], ["64075.41000000", "0.01195000"], ["64074.36000000", "0.00017000"], ["64074.34000000", "0.03122000"], ["64074.01000000", "0.00009000"], ["64074.00000000", "0.10750000"], ["64073.13000000", "0.04000000"], ["64072.60000000", "0.00009000"], ["64072.00000000", "0.10750000"]], "asks": [["64076.45000000", "4.16141000"], ["64076.46000000", "0.34852000"], ["64077.83000000", "0.04693000"], ["64078.00000000", "0.17000000"], ["64078.59000000", "0.23239000"], ["64078.60000000", "0.23850000"], ["64078.61000000", "2.00292000"], ["64078.62000000", "0.65870000"], ["64079.22000000", "0.05865000"], ["64079.44000000", "0.00080000"]], "datetime": "1724457623.4246445"}
{"e": "aggTrade", "E": 1724457623410, "s": "BTCUSDT", "a": 3125698689, "p": "64076.44000000", "q": "0.01006000", "f": 3761589261, "l": 3761589261, "T": 1724457623409, "m": true, "M": true, "datetime": "1724457623.51936"}
{"lastUpdateId": 50754183516, "bids": [["64076.44000000", "0.28281000"], ["64075.44000000", "0.00009000"], ["64075.43000000", "0.04000000"], ["64075.42000000", "0.00019000"], ["64075.41000000", "0.01195000"], ["64074.51000000", "0.00009000"], ["64074.50000000", "0.06250000"], ["64074.36000000", "0.00017000"], ["64074.34000000", "0.03122000"], ["64074.01000000", "0.00009000"]], "asks": [["64076.45000000", "4.73287000"], ["64076.46000000", "0.34852000"], ["64077.83000000", "0.04693000"], ["64078.00000000", "0.17000000"], ["64078.59000000", "0.07590000"], ["64078.60000000", "0.55036000"], ["64078.61000000", "0.22370000"], ["64078.62000000", "0.21948000"], ["64079.21000000", "0.06608000"], ["64079.22000000", "0.05865000"]], "datetime": "1724457623.5247931"}
# 系统时间是UTC

这段数据是从币安 (Binance) API 提取的一部分原始交易数据，主要包含了比特币（BTC）对美元（USDT）的交易信息。让我用简单易懂的方式解释这些数据。
它包含两种类型的数据：
逐笔交易数据 (aggTrade)
订单簿快照 (order book snapshot)
我们逐一解释这些数据。
1. 逐笔交易数据 (aggTrade)
每个 { "e": "aggTrade", ... } 开头的部分代表一笔已完成的交易的详细信息，具体包含以下字段：
"e": "aggTrade"：表示这是一个聚合交易信息。
"E"：事件时间，以毫秒为单位。比如 "E": 1724457623290 是事件发生的时间。
"s": "BTCUSDT"：交易的交易对，在这里是 BTC 对 USDT，表示用美元购买比特币。
"a"：交易 ID，例如 "a": 3125698687，每笔交易都有一个唯一的 ID。
"p"：价格，例如 "p": "64078.61000000"，表示这一笔交易的成交价格是 64078.61 美元。
"q"：数量，例如 "q": "0.10894000"，表示这一笔交易中买卖的比特币数量为 0.10894 个。
"f" 和 "l"：这两个字段代表了这笔交易的起始和结束的订单 ID，这对于追踪交易来源很有用。
"T"：交易时间，以毫秒为单位，比如 "T": 1724457623289，表示该交易发生的时间。
"m"：表示是否是“买单成交”，true 代表该交易是由卖方发起，意味着买方接收了卖方的价格。
"M"：此字段目前固定为 true，在此例子中不太影响理解。
"datetime"：这是将时间戳转换为一个可读日期时间格式的字段。
简单来说，每个 aggTrade 代表了一次比特币的买卖交易，包含了成交的价格、数量和交易发生的时间。
2. 订单簿快照 (order book snapshot)
每个 { "lastUpdateId": ... } 开头的部分代表当前订单簿的快照。订单簿显示了市场上买入和卖出订单的情况。以下是每个字段的含义：
"lastUpdateId"：最新订单更新的 ID，标识订单簿的状态。
"bids"：所有买入订单列表。每一个买单包含了两个值：价格和数量，例如 "64076.44000000", "0.01987000"，表示有人愿意以 64076.44 美元的价格购买 0.01987 个比特币。
"asks"：所有卖出订单列表。每一个卖单包含了两个值：价格和数量，例如 "64076.45000000", "4.16141000"，表示有人愿意以 64076.45 美元的价格卖出 4.16141 个比特币。
"datetime"：这是一个包含快照时间戳的字段，用来记录快照生成的时间。
订单簿 是一个包含市场上所有买入和卖出订单的结构，分为两部分：
bids：是买入的意向（别人希望买进比特币），这些通常会按价格从高到低排列。
asks：是卖出的意向（别人希望卖出比特币），这些通常会按价格从低到高排列。
总结一下：
aggTrade 数据表示的是已经完成的交易，告诉你具体有多少比特币以什么价格成交。
订单簿数据告诉你当前市场上的买卖情况，有哪些人在排队买入和卖出。
这些数据通常用来帮助交易者了解市场动态，分析交易行为，或者自动化交易机器人来决策是否买入或卖出。希望这样解释让你更好地理解了这段数据的含义。


### 订单执行的基本原理

在交易平台上，订单执行的核心是 **订单簿**（order book）。订单簿是由两部分组成：
- **买入订单 (bids)**：交易者愿意支付的价格，想要购买的数量。
- **卖出订单 (asks)**：交易者愿意接受的价格，想要出售的数量。

当你在交易平台上下订单时，有两种主要类型的订单：
1. **市价订单 (Market Order)**：即以市场当前最优价格立即执行的订单。
2. **限价订单 (Limit Order)**：你可以自己设定价格，等待其他交易者来与之成交。

市价订单会立即在订单簿中与现有的挂单成交，而限价订单则会等待与其他订单匹配。

### 具体示例：买入 1 BTC 和卖出 1 BTC

#### 场景一：买入 1 BTC（市价订单）

假设当前订单簿的卖单（asks）部分如下：

- 价格 64076.45 美元，有 4.16141 个 BTC 待售
- 价格 64076.46 美元，有 0.34852 个 BTC 待售
- 价格 64077.83 美元，有 0.04693 个 BTC 待售

如果你想 **市价买入 1 BTC**，订单将如何执行？

1. 系统会首先在订单簿中找到价格最低的卖单（asks）。
2. 你的订单会与 64076.45 美元的卖单匹配，买入部分 BTC。
   - 你需要买 1 BTC，但当前价格 64076.45 美元的卖单有 4.16141 个 BTC，这足够满足你的需求。
   - 因此，你会以 64076.45 美元的价格买到 1 BTC。
3. 买入后，这个卖单（asks）中的数量会减少 1 个 BTC，变为 **4.16141 - 1 = 3.16141** 个 BTC。
4. 因为你已经成功买到了 1 个 BTC，订单执行完成，不需要再继续向上匹配更多卖单。

最终，订单簿的变化是：
- 价格 64076.45 美元的卖单数量变为 3.16141 个 BTC。

#### 场景二：卖出 1 BTC（市价订单）

假设当前订单簿的买单（bids）部分如下：

- 价格 64076.44 美元，有 0.28281 个 BTC 想买入
- 价格 64075.44 美元，有 0.00009 个 BTC 想买入
- 价格 64075.43 美元，有 0.04 个 BTC 想买入

如果你想 **市价卖出 1 BTC**，订单将如何执行？

1. 系统会首先在订单簿中找到价格最高的买单（bids）。
2. 你的订单会与 64076.44 美元的买单匹配，卖出部分 BTC。
   - 价格 64076.44 美元的买单有 0.28281 个 BTC，这个数量不足以全部匹配你想卖的 1 个 BTC。
   - 因此，你首先以 64076.44 美元的价格卖出 0.28281 个 BTC。
3. 剩下你还要卖出 **1 - 0.28281 = 0.71719** 个 BTC。系统会继续向下匹配下一个买单。
   - 价格 64075.44 美元的买单有 0.00009 个 BTC，再卖出 0.00009 个 BTC。
   - 剩余要卖的数量为 **0.71719 - 0.00009 = 0.7171** 个 BTC。
   - 继续向下匹配下一个买单。
   - 价格 64075.43 美元的买单有 0.04 个 BTC，继续卖出 0.04 个 BTC。
   - 剩余要卖的数量为 **0.7171 - 0.04 = 0.6771** 个 BTC。
4. 这个过程会继续，直到你的卖单全部成交为止。最终的价格会因为逐步匹配多个买单而略有不同。

最终，订单簿的变化是：
- 价格 64076.44 美元的买单数量变为 0，因为你已经全部卖掉了那部分。
- 价格 64075.44 美元的买单数量变为 0，同样全部卖出。
- 价格 64075.43 美元的买单数量减少到 0，因为你也完成了那部分交易。

### 限价订单的情况

如果你选择限价买入或卖出，例如你希望以 **64075 美元的价格买入 1 个 BTC**，你的订单会被添加到订单簿中，等待市场上的卖家以你愿意支付的价格（64075 美元）来卖出 BTC。

这时，你的订单会显示在订单簿的 **买单 (bids)** 列表中，直到有卖家愿意接受你提出的价格，订单才会被执行。

### 结论

- **市价订单**：立即与订单簿中的现有挂单匹配，快速成交。
- **限价订单**：会挂在订单簿中，等待其他交易者来匹配。

通过订单簿的变化，我们可以看到如何一步一步地执行交易。市价订单能够立即执行，但价格可能会波动，因为要匹配多个挂单；而限价订单则能确保以指定价格成交，但需要等待合适的机会。希望这个解释帮助你理解订单是如何执行的！


这个是对LOBdata和aggtradedata的解释。


从 0lobretrieve.py 到 9_backtester.ipynb：
请见 操作指南文件夹(gpt 输出可能会有错误所以小心用操作指南里的代码 解释是可以的)

0lobretrieve.py: 通过binance api 获得limit orderbook data. 
1_build_orderbook.py: 请见代码 
1.1: 请见代码
1.21: 为aggregate_by_dollar_volume做准备
aggregate by dollar volume 介绍： 一种data-thinning technique （字面意思）请看介绍1.99expn.md
1.99:请见指南解释

2 的一堆是对数据结构的实验 和可视化 帮助人理解数据。
3-4 是lstm有关的 类似于一个baseline
7是目前跑过的框架 比较有可行性 
8：
总结来说，这个代码的目标是通过元标注模型来预测金融市场中的价格走势，并对交易数据进行分析和标记，以确定买卖时机。元标注模型本质上是为了在某些基本预测模型的基础上，进一步通过标注来提高预测精度和交易的决策能力。这对于高频交易（HFT）和对冲基金等应用场景特别有用，因为这些场景需要对价格变化进行精确的预测并快速反应。 具体参见8expn.md

9:backtesting

运行顺序： 1-1.1-1.21-1.99-7-9（一种跑得通的路径，可能需要改路径名什么的）8目前我还没用到 但是idea你们可以看看

对于benchmark 你们来看吧 一种就是你们说的找网上的benchmark一种就是改进backtest. 训练数据不能在backtest数据里面。backtest要符合市场实际（按照我的描述做）



